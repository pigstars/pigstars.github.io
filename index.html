<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-反应堆" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/24/反应堆/" class="article-date">
  <time datetime="2017-06-24T15:21:06.000Z" itemprop="datePublished">2017-06-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="反应堆"><a href="#反应堆" class="headerlink" title="反应堆"></a>反应堆</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/06/24/反应堆/" data-id="cj4calb0600084q985xtrwzpo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Nginx" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/21/Nginx/" class="article-date">
  <time datetime="2017-06-21T13:41:47.000Z" itemprop="datePublished">2017-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>nginx 服务运行时，会有一个主进程和一个或多个worker process 工作进程</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/06/21/Nginx/" data-id="cj4calb0100064q98qa0dk2ow" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-服务器端编程介绍" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/30/服务器端编程介绍/" class="article-date">
  <time datetime="2017-05-30T14:32:42.000Z" itemprop="datePublished">2017-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#服务器端编程介绍</p>
<p>##正向代理：<br>用户请求网站，通过代理请求。因此，正向代理隐藏了真实的请求客户端，服务器不知道真实的客服端。<br>例如：科学上网工具ss，</p>
<p><img src="media/14961547625054/v2-07ededff1d415c1fa2db3fd89378eda0_r.jpg" alt="v2-07ededff1d415c1fa2db3fd89378eda0"></p>
<p>##反向代理：<br>用户请求网站，可能请求的服务器为负载均衡服务器。该服务器来寻找空闲服务器，将用户请求分发到空闲服务器。因此，反向代理隐藏了真实的服务端。<br>例如：Nginx 反向代理服务器，用来做负载均衡</p>
<p><img src="media/14961547625054/v2-816f7595d80b7ef36bf958764a873cba_b.jpg" alt="v2-816f7595d80b7ef36bf958764a873cba_b"></p>
<p>#负载均衡<br>负载均衡包含两方面含义：<br>一方面，将单一的重负载分担到多个网络节点上作并行处理，每个节点处理结束后将结果汇总返回给用户，大幅度提高网络系统的处理能力。<br>另一方方面：将大量的前端并发访问火数据流量分担到多个后端网络节点上分别处理，有效减短前端用户等待时间。</p>
<p>#CGI／FastCGI（通用网关接口／快速通用网关接口）<br>CGI 通用网关接口，让一个客户端从网络浏览器向执行在服务器上的程序请求数据。<br>CGI工作方式：</p>
<ul>
<li>HTTP Server接受客户端请求</li>
<li>提取客户端请求</li>
<li>生成一个字符串数组，将相应的环境变量放入</li>
<li>fork子进程，使用exec系列调用CGI程序，并且把相应的环境变量放入</li>
<li>子进程的stdout直接就是发送给客户端的代码</li>
</ul>
<p>FastCGI 在第一次调用脚本时，在系统的某个地方保存脚本编译过的版本。可以避免每次调用脚本时编译文件。</p>
<p>#管道<br>管道是一种最基本的IPC机制</p>
<ul>
<li>历史上，为半双工</li>
<li>管道只能在具有公共祖先的两个进程之间使用</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>; <span class="comment">//fd[0]为读而打开 fd[1] 为写而打开</span></div></pre></td></tr></table></figure>
<ul>
<li>读一个写端已被关闭的管道时，所有数据都被读取后，read返回0，表示文件结束</li>
<li>写一个读端已经被关闭的管道时，则产生信号SIGPIPE。如果忽略该-信号或者捕捉该信号并从其处理程序返回，则write返回-1</li>
</ul>
<p>##读管道：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">管道中有数据</div><div class="line">   read 返回实际读到的字节数</div><div class="line">管道中无数据</div><div class="line">   管道写端被全部关闭</div><div class="line">       read 返回0</div><div class="line">   管道写端没有全部关闭</div><div class="line">       read阻塞等待</div></pre></td></tr></table></figure></p>
<p>##写管道<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">管道读端全部被关闭，进程异常终止</div><div class="line">管道读端没有全部关闭</div><div class="line">   管道已满</div><div class="line">       write 阻塞</div><div class="line">   管道未满</div><div class="line">       write将数据写入，并返回实际写入的字节数</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/30/服务器端编程介绍/" data-id="cj4calb0300074q98k20cswxp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-C++ Primer Plus[5-9] 章总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/24/C++ Primer Plus[5-9] 章总结/" class="article-date">
  <time datetime="2017-05-24T01:53:47.000Z" itemprop="datePublished">2017-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="C-Primer-Plus-5-9-章总结"><a href="#C-Primer-Plus-5-9-章总结" class="headerlink" title="C++ Primer Plus[5-9] 章总结"></a>C++ Primer Plus[5-9] 章总结</h1><p>##第5章循环和关系表达式</p>
<ul>
<li>读取char址时，cin将忽略空格和换行符</li>
<li><p>cin.get两个版本</p>
<ul>
<li>cin.get(name,ArSize) 接受字符串的地址和长度</li>
<li>cin.get(ch) // 返回cin对象</li>
<li>ch = cin.get()  //返回字符对象</li>
</ul>
<p>类型 | 传递输入字符的方式 | 用于字符输入时的函数返回值 | 到达EOF时的函数返回值<br>— | — | — |—<br>cin.get(ch) | 赋值给参数 | istream对象（执行bool转换后为true）| istream对象 （执行bool为false）<br>ch = cin.get() | 将函数返回给ch | int类型的字符编码 | EOF </p>
</li>
</ul>
<p>##第6章 分支语句和逻辑运算符<br>和C类似</p>
<p>##第7章 函数–C++的编程模块</p>
<ul>
<li>若定义的为数字类型的，cin时输入字符类型的，将设置错误调节，禁止进一步读取输入，必须使用cin.clear()重置输入。</li>
<li>函数指针</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ToUpper</span> <span class="params">(<span class="keyword">char</span> * )</span> <span class="comment">// 函数声明</span></span></div><div class="line"></div><div class="line"><span class="title">void</span> <span class="params">(*pf)</span><span class="params">(<span class="keyword">char</span> * )</span> <span class="comment">// 声明函数指针pf.该指针指向的函数接受一个字符指针，返回值为void.</span></div><div class="line"></div><div class="line"><span class="title">void</span> <span class="params">(*pf[<span class="number">3</span>])</span><span class="params">(<span class="keyword">char</span> *)</span> <span class="comment">//声明函数包含三个函数指针的数组</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> * <span class="params">(*pf[<span class="number">3</span>])</span><span class="params">(<span class="keyword">char</span> *)</span> <span class="comment">//声明一个指向包含三个函数指针的数组的指针</span></div><div class="line"></div><div class="line"><span class="keyword">auto</span> pf2 = pf <span class="comment">// 使用C++11的自动类型推断功能，可以直接使得pf2的类型为pf的类型</span></div><div class="line"></div><div class="line">(*pf)(mis) </div><div class="line">ToUpper(mis) <span class="comment">// 两者等价，都表示执行函数ToUpper</span></div></pre></td></tr></table></figure>
<p>##第8章 函数探幽</p>
<ul>
<li>内联函数，适合小型，非递归函数。编译器使用相应的函数代码替换函数调用，内联函数的运行速度比常规的函数稍快。<ul>
<li>在函数的声明和定义前加上关键字 inline</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;<span class="keyword">return</span> x*x&#125;;</div></pre></td></tr></table></figure>
<ul>
<li><strong>引用变量</strong>,引用是已定义的变量的别名，主要用途：用作函数的形参。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> rats;</div><div class="line"><span class="keyword">int</span> &amp; rodents 　　= rats; <span class="comment">// 必须在声明引用时将其初始化，参数必须时变量。不能是表达式。</span></div><div class="line"><span class="keyword">int</span> &amp;&amp; jerf = <span class="number">2.0</span>*j + <span class="number">18.5</span> <span class="comment">// C++11 新增了另一种引用，右值引用，可指向右值</span></div></pre></td></tr></table></figure>
<ul>
<li>返回引用的函数实际上时被引用的变量的别名，避免返回函数终止时不在内存中的内存单元的引用。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">const</span> free_throw &amp; <span class="title">clone</span><span class="params">(free_throw &amp; ft)</span></span></div><div class="line">&#123;</div><div class="line">    free_throw newguy;</div><div class="line">    newguy = ft;</div><div class="line">    <span class="keyword">return</span> newguy;</div><div class="line">&#125;</div><div class="line"><span class="comment">//函数结束时，newguy内存被回收，</span></div><div class="line"><span class="comment">// 解决方法：</span></div><div class="line"><span class="comment">// 返回一个作为参数传递给函数的引用</span></div><div class="line"><span class="comment">// 用new分配新的存储空间，</span></div></pre></td></tr></table></figure>
<p>使用引用参数原因：程序员能够修改调用函数的中的数据对象<br>通过传递引用而不是整个数据对象，可以提高程序的运行速度。<br>数组的函数调用只能使用指针</p>
<ul>
<li>默认参数，</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">harpo</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m = <span class="number">4</span>,<span class="keyword">int</span> j = <span class="number">5</span>)</span> <span class="comment">// 必须从右向左添加默认值</span></span></div></pre></td></tr></table></figure>
<ul>
<li>函数重载的关键时函数的参数列表（函数的特征标），参数数目和／或参数类型不同，特征标不同。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">gronk</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">float</span> m)</span></span>;</div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">gronk</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">float</span> m)</span></span>;</div><div class="line"><span class="comment">// 非法，两个声明互斥，无法重载。函数重载返回类型可以不同，但特征标也必须不同</span></div></pre></td></tr></table></figure>
<ul>
<li>名称修饰：C++用来跟踪每一个重载函数，根据函数原型中指定的形参类型对每个函数名进行加密</li>
<li>函数模板：通用函数的描述</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">template &lt;typename AnyType&gt;</div><div class="line">void swap(AnyType &amp;a , AnyType &amp;b); // 原型</div><div class="line"></div><div class="line">template &lt;typename AnyType&gt;</div><div class="line">void swap(AnyType &amp;a ,AnyType &amp;b)</div><div class="line">&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>编写的模板函数很有可能无法处理某些类型：</li>
</ul>
<ul>
<li>显示具体化：提供一个具体化函数定义<br>具体化优先于常规模版，而非模板函数优先于具体化和常规模板</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">void</span> Swap&lt;job&gt; (job &amp; ,job &amp;); <span class="comment">// 函数原型</span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">void</span> Swap&lt;job&gt; (job &amp; j1,job &amp; j2) <span class="comment">// 函数定义</span></div><div class="line">&#123; </div><div class="line"></div><div class="line">&#125;  <span class="comment">// &lt;job&gt;可省略</span></div></pre></td></tr></table></figure>
<ul>
<li>实例化<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> <span class="keyword">void</span> Swap&lt;<span class="keyword">int</span>&gt;(<span class="keyword">int</span> &amp;,<span class="keyword">int</span> &amp;); <span class="comment">//显式实例化只需声明，不需要重新定义。编译器根据模板实现实例声明和实例定义。</span></div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>重载解析将寻找最匹配的函数。</p>
<ul>
<li>只存在一个，则选择</li>
<li>多个适合函数，只有一个非模板，选择非模板</li>
<li>多个适合函数，都为模板函数，选择最具体的模板函数</li>
<li>多个同样合适的非模板函数或模板函数，则错误</li>
</ul>
</li>
<li><p>自定义选择  </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lesser&lt;&gt;(m,n) // 编译器应该选择模板函数，而不是非模板函数</div><div class="line">lesser&lt;int&gt;(m,n) //使用显示实例化得到的函数</div></pre></td></tr></table></figure>
<ul>
<li>decltype 用于查询表达式的数据类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int x;</div><div class="line">decltype(x) w;</div><div class="line">long indeed(int);</div><div class="line">decltype (indeed(3)) m // 不会实际调用函数，编译器通过查看函数的原型来获悉返回类型，而无需实际调用函数</div></pre></td></tr></table></figure>
<ul>
<li>后置返回类型  </li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">auto h(int x, int y) -&gt; decltype(x+y)</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>##第9章 内存模型和名称空间</p>
<ul>
<li>C++11使用四种方式存储数据<br>自动存储持续性，静态存储持续性，线程存储持续性（C++11） thread_local，动态存储持续性 new delete </li>
<li>所有未被初始化的静态变量的所有位都被设置为0</li>
<li>单定义规则，变量只能有一次定义。C++提供两种变量声明：一种定义声明，给变量分配存储空间。另一种引用声明，不给变量分配空间，关键字extern。<br>如果要在多个文件中使用外部变量，只需在一个文件中包含该变量的定义，但在使用该变量的其他所有文件中，使用extern声明它。<br>C++提供了作用域解析运算符::，放在变量名前面时，表示使用变量的全局版本</li>
<li>volatile 表明即使程序代码没有对内存单元进行修改，其值也可能发生变化。告诉编译器，不能进行一些优化</li>
<li>const 表明内存被初始化后，程序编不能再对它它进行修改。const全局变量的链接性为内部，全局const定义相当于使用了static说明符。如果希望常量为外部链接性：extern const int states = 50</li>
<li>函数的链接性<br>所有函数的存储性都自动为静态，默认为外部。使用static将函数的链接性设置为内部，使之只能在一个文件中使用。</li>
<li>语言的链接性</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">extern "C" void spiiff (int)</div><div class="line">extern "C++" void spaff(int)</div></pre></td></tr></table></figure>
<ul>
<li>定位new运算符 </li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> buffer[<span class="number">512</span>];</div><div class="line"><span class="keyword">double</span> * p1x</div><div class="line">p1 = <span class="keyword">new</span> (buffer) <span class="keyword">double</span> [N];  <span class="comment">// new运算符使用传递给它的地址</span></div></pre></td></tr></table></figure>
<ul>
<li>名称空间：<br>用户定义名称空间：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> Jack&#123;</div><div class="line">    <span class="keyword">double</span> pail;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fetch</span><span class="params">()</span></span>;</div><div class="line">    <span class="keyword">int</span> pal;</div><div class="line">&#125;</div><div class="line"><span class="keyword">namespace</span> Jill&#123;         <span class="comment">// 名称空间嵌套</span></div><div class="line">    <span class="keyword">double</span> fetch;</div><div class="line">    <span class="keyword">namespace</span> Bill</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> flame;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">float</span> pal;</div><div class="line">&#125;   <span class="comment">// using namespace Jill::Bill</span></div><div class="line">    </div><div class="line"><span class="keyword">namespace</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> ice;</div><div class="line">    <span class="keyword">int</span> bandyycoot;</div><div class="line">&#125;    <span class="comment">// 潜在作用域为从声明点到声明区域末尾</span></div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/24/C++ Primer Plus[5-9] 章总结/" data-id="cj4calazz00054q98o9upp00e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-C Primer Plus [1-10] 章总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/22/C Primer Plus [1-10] 章总结/" class="article-date">
  <time datetime="2017-05-22T12:28:03.000Z" itemprop="datePublished">2017-05-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="C-Primer-Plus-1-10-章总结"><a href="#C-Primer-Plus-1-10-章总结" class="headerlink" title="C Primer Plus [1-10] 章总结"></a>C Primer Plus [1-10] 章总结</h1><h2 id="第1章-初识C语言"><a href="#第1章-初识C语言" class="headerlink" title="第1章 初识C语言"></a>第1章 初识C语言</h2><ul>
<li><p>1972年，贝尔实验室的丹尼斯.里奇和肯.汤普逊开发UNIX操作系统的时候设计了C语言。</p>
</li>
<li><p>使用C语言七个步骤<br>  定义程序目标 -&gt; 设计程序 -&gt; 编写代码 -&gt; 编译-&gt; 运行程序 -&gt; 测试和调试程序 -&gt; 维护和修改代码</p>
</li>
<li><p>语言标准：<br>1989年美国国家标准协会（ANSI）公布<strong>ANSI C</strong>。国际标准化组织与1990年采用这套C标准，最终版本通常称为<strong>C 89</strong> 或 <strong>C90</strong><br>1994 ANSI／ISO 联合委员会开始修订C标准最终发布<strong>C 99</strong> 标准<br>2011年，标准委员会发布C11标准</p>
</li>
</ul>
<h2 id="第2章-C语言概述"><a href="#第2章-C语言概述" class="headerlink" title="第2章 C语言概述"></a>第2章 C语言概述</h2><ul>
<li>实际参数：是传递给函数的特定值<br>形式参数：是函数中用于储存值的变量</li>
</ul>
<h2 id="第3章-数据和C"><a href="#第3章-数据和C" class="headerlink" title="第3章 数据和C"></a>第3章 数据和C</h2><ul>
<li><p>显示十进制 %d<br>显示八进制 %o 若要显示前缀0 则为%#o<br>显示十六进制 %x  若要显示前缀0x则为 %#x 若要显示前缀0X 则为%#X   </p>
</li>
<li><p>int – 系统给定的基本参数类型，C语言规定int类型不小于16位<br>short或short int – 最大的short类型整数小于或等于最大的int类型整数，C语言规定short类型至少16位<br>long或long int – 该类型可表示的整数大于或等于最大的int类型整数。long 类型至少占32位<br>long long或long long int – 该类型可表示的整数大于或等于最大的long类型整数。long long 类型至少占64位<br>char – 字符类型关键字。占用一个字节内存，<br>float – 可精确表示至少6位有效数字<br>double – 能表示比float类型更多的有效数字（至少十位）<br>long double – </p>
<blockquote>
<p>32位编译器：<br>   char ：1个字节<br>   char*（即指针变量）: 4个字节（32位的寻址空间是2^32, 即32个bit，也就是4个字节。同理64位编译器）<br>   short int : 2个字节<br>   int：  4个字节<br>   unsigned int : 4个字节<br>   float:  4个字节<br>   double:   8个字节<br>   long:   4个字节<br>   long long:  8个字节<br>   unsigned long:  4个字节</p>
<p>64位编译器：<br>   char ：1个字节<br>   char*(即指针变量): 8个字节<br>   short int : 2个字节<br>   int：  4个字节<br>   unsigned int : 4个字节<br>   float:  4个字节<br>   double:   8个字节<br>   long:   8个字节<br>   long long:  8个字节<br>   unsigned long:  8个字节</p>
</blockquote>
<ul>
<li>刷新输出<br>当缓冲区满，遇到换行字符或需要输入的时候把缓冲区中的内容发送到屏幕.</li>
</ul>
</li>
</ul>
<h2 id="第4章-字符串与格式化输入／输出"><a href="#第4章-字符串与格式化输入／输出" class="headerlink" title="第4章 字符串与格式化输入／输出"></a>第4章 字符串与格式化输入／输出</h2><ul>
<li>strlen（） 不记录字符串结尾空字符 \0</li>
<li>sizeof  记录字符串结尾空字符 \0</li>
<li>printf 返回值，返回打印字的个数，若出现错误返回负值</li>
<li>scanf 返回值，返回成功读取的项数，如果没有读取任何项，且需要读取一个数字而用户却输入一个非数字字符串，则返回0</li>
<li>printf 用*修饰符来代替字段宽度，用一个参数告诉函数，字段宽度应该是多少</li>
<li>scanf 用*来跳过相应的输出项</li>
</ul>
<h2 id="第5章-运算符、表达式和语句"><a href="#第5章-运算符、表达式和语句" class="headerlink" title="第5章 运算符、表达式和语句"></a>第5章 运算符、表达式和语句</h2><ul>
<li>优先级 递增运算符和递减运算符都有很高的结合优先级，只有圆括号的优先级比它们高</li>
<li>副作用：对数据对象或文件的修改</li>
<li>序列点：在一个语句中，赋值运算符、递增运算符和递减运算符对运算对象做的改变必须在程序执行下一语句之前完成</li>
</ul>
<h2 id="第6章-C控制语句：循环"><a href="#第6章-C控制语句：循环" class="headerlink" title="第6章 C控制语句：循环"></a>第6章 C控制语句：循环</h2><ul>
<li>比较浮点数时尽量采用&lt;和&gt;，应该使用fabs()控制。</li>
<li>关系运算符的优先级比运算符（包括+和-）低，比赋值运算符高</li>
</ul>
<h2 id="第7章-C控制语句：分支和跳转"><a href="#第7章-C控制语句：分支和跳转" class="headerlink" title="第7章 C控制语句：分支和跳转"></a>第7章 C控制语句：分支和跳转</h2><ul>
<li>！运算符的优先级很高，比乘法运算符还高，与递增运算符的优先级相同，只比圆括号的优先级低。&amp;&amp;的运算符的优先级比||运算符高，但是两者的优先级都比关系运算符低，比赋值运算符高。<br>圆括号 》 递增递减运算符，！运算符 》 运算符 》关系运算符 》 &amp;&amp;，|| 》赋值运算符</li>
</ul>
<h2 id="第8章-字符输入／输出和输入验证"><a href="#第8章-字符输入／输出和输入验证" class="headerlink" title="第8章 字符输入／输出和输入验证"></a>第8章 字符输入／输出和输入验证</h2><ul>
<li>C把输入和输出设备视为存储设备上的普通文件，尤其是把键盘和显示设备视为每个C程序自动打开的文件。stdin流表示键盘输入，stdout流表示屏幕输出。</li>
<li>重定向<br>  1 把输出重定向至文件： &gt;<br>  2 把输入重定向至文件： &lt;</li>
</ul>
<h2 id="第9章-函数"><a href="#第9章-函数" class="headerlink" title="第9章 函数"></a>第9章 函数</h2><ul>
<li>函数声明中的变量名是假名，不必于函数定义的形式参数名一致</li>
</ul>
<h2 id="第10章-数组和指针"><a href="#第10章-数组和指针" class="headerlink" title="第10章 数组和指针"></a>第10章 数组和指针</h2><ul>
<li>数组初始化控制器<br>  int arr[6]={[3]=233}  // 0,0,0,233,0…<br>  int arr[10]={[3]=233,366}  // 0，0，0，233，366…<br>  如果初始化的数值不够，则按照先后顺序逐行初始化，直到用完所有值。</li>
<li>对于指针而言，加1后的地址是下一个元素的地址。</li>
<li>声明指针对象类型：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *p[<span class="number">3</span>] <span class="comment">//表示指针数组 </span></div><div class="line"><span class="keyword">int</span> (*p)[<span class="number">3</span>]  <span class="comment">//表示指向3个int的指针，例如指向a[2][3]</span></div></pre></td></tr></table></figure>
<ul>
<li>只有在函数原型或函数定义头中，才可以用int ar[]代替int *ar</li>
<li>对函数传数组<br>数组传参    </li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">void sum(int ar[],int n ）  // 一维数组</div><div class="line">void sum(int ar[][COlS],int n)   //二维数组</div><div class="line">void sum(int ar[ROW][COLs],int ROW,int COLS)    </div><div class="line">void sum(int **arr,int m, int n)      </div><div class="line">&#123;  </div><div class="line">*((int*)arr + n*i + j);    </div><div class="line">&#125;</div><div class="line">```		  </div><div class="line">变长数组： void sum(int n, int m,int ar[n][m]) </div><div class="line"> </div><div class="line">- 指向常量的指针：</div><div class="line"></div><div class="line">```C</div><div class="line">const int *pa ;int const *pa;   //表示不能使用pa来更改它所指向的值 </div><div class="line">*pa=5 不可行    </div><div class="line">*pa=&amp;d 可行</div><div class="line">```	</div><div class="line">- 常量指针：</div><div class="line"></div><div class="line">```C</div><div class="line">double rates[5]=&#123;88.99,100.12,59.45,182.11,33,7&#125;</div><div class="line">double *const pc=rates</div><div class="line">pc=&amp;rates[2] 不允许</div><div class="line">*pc=99.88 允许</div><div class="line">```	</div><div class="line"></div><div class="line">- 双层 const</div><div class="line"></div><div class="line">```C</div><div class="line">double rares[5]=&#123;88.99,100.12,59.45,182.11,33,7&#125;</div><div class="line">const double * const pc=&amp;rates</div><div class="line">//该指针既不能更改它所指向的地址，也不能修改指向的地址上的值</div></pre></td></tr></table></figure>
<ul>
<li>C99标准，加入复合字面量<br>普通数组声明： </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> diva[<span class="number">2</span>]=&#123;<span class="number">10</span>,<span class="number">20</span>&#125;; <span class="comment">// 普通定义方法</span></div><div class="line">(<span class="keyword">int</span> [<span class="number">2</span>])&#123;<span class="number">10</span>,<span class="number">20</span>&#125;;  <span class="comment">// 复合字面量</span></div></pre></td></tr></table></figure>
<p>还可以把复合字面量作为实际参数传递给带有匹配形式参数的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">total3 = sum((<span class="keyword">int</span> [])&#123;<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>&#125;);</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/22/C Primer Plus [1-10] 章总结/" data-id="cj4calazo00004q984lqdjjte" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-C Primer Plus [11-13] 章总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/22/C Primer Plus [11-13] 章总结/" class="article-date">
  <time datetime="2017-05-22T12:28:03.000Z" itemprop="datePublished">2017-05-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="C-Primer-Plus-11-13-章总结"><a href="#C-Primer-Plus-11-13-章总结" class="headerlink" title="C Primer Plus [11-13] 章总结"></a>C Primer Plus [11-13] 章总结</h1><h2 id="第11章-字符串与字符串函数"><a href="#第11章-字符串与字符串函数" class="headerlink" title="第11章 字符串与字符串函数"></a>第11章 字符串与字符串函数</h2><ul>
<li>从ANSI标准起，如果字符串字面量之间没有间隔，或者用空白字符间隔，C将其视为串联起来的字面量<br>例如：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> greet[<span class="number">50</span>]=<span class="string">"Hello,"</span><span class="string">"how are you"</span>    <span class="string">"are you ok?"</span></div><div class="line">  等价于</div><div class="line"><span class="keyword">char</span> greet[<span class="number">50</span>]=<span class="string">"Hello,how are you are you ok"</span></div></pre></td></tr></table></figure>
<ul>
<li>初始化数组是把静态存储区的字符串拷贝到数组中，而初始化指针只把字符串的地址拷贝给指针，（当通过该地址修改字符串时，再次输出相同与静态存储区的值可能会发生变化）<br>例如：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> *p1 = “Klingon”;</div><div class="line">p1[<span class="number">0</span>] = <span class="string">'F'</span>;</div><div class="line">print(<span class="string">"Klingon"</span>);</div><div class="line">print(<span class="string">":Beware the %s!\n"</span>,<span class="string">"Klingon"</span>)</div><div class="line">	<span class="comment">// 打印结果可能为 Flingon</span></div></pre></td></tr></table></figure>
<ul>
<li><p>gets函数可能存在读入的长度超过数组长度的问题<br>替代函数<br>fgets()函数：<br>  第1个参数表示储存的数组<br>  第2个参数限制读入的字符数来解决溢出的问题<br>  第3个参数指明要读入的文件<br>  不添加换行符<br>get_s()函数：<br>  只从标准输入中读取数据<br>  读到换行符会丢弃<br>  读到最大字符数没有读到换行符，执行以下首先把目标数组中的首字符设置为空字符，读取并丢弃随后的输入直至读到换行符或文件结尾，然后返回空指针。</p>
</li>
<li><p>strncmp() 可以比较到字符不同的地方，也可以只比较第3个参数所指定的字符数</p>
</li>
<li>strncpy() 第三个参数指明可拷贝的最大字符数</li>
<li>sprintf()函数将数据写入字符串，而不是打印在显示器</li>
<li>命令行参数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></div></pre></td></tr></table></figure>
<p>argc 表示参数个数<br>argv 表示指向参数数组指针的指针<br>argv[0] 表示程序名</p>
<p>##第12章 存储类别，链接和内存管理</p>
<p>###作用域</p>
<ul>
<li><p>作用域描述程序中可访问标志符的区域<br>C变量的作用域可以是</p>
<ul>
<li>块作用域</li>
<li>函数作用域</li>
<li>函数原型作用域</li>
<li>文件作用域</li>
</ul>
</li>
<li><p>块作用域：从定义处到包含该定义的块的末尾，局部变量（包括函数的形式参数） C99允许在块中的任意位置声明变量</p>
</li>
<li><p>函数作用域：仅用于GOTO语句的标签</p>
</li>
<li><p>函数原型作用域：用于函数原型中的形参名</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mighty</span><span class="params">(<span class="keyword">int</span> mouse,<span class="keyword">double</span> large)</span></span></div></pre></td></tr></table></figure>
<p>范围是从形参定义处到原型声明结束，编译器在处理函数原型中的形参时，只关心类型，而形参名无关紧要。</p>
<p>文件作用域：变量定义在函数的外部，也称为全局变量</p>
<p>翻译单元</p>
<blockquote>
<p>编译器源代码文件和所有的头文件看成是一个包含信息的单独文件，称为翻译单元。描述一个具有文件作用域的变量时，它的实际可见范围是整个翻译单元。<br>如果程序由多个源代码文件组成，那么该程序也将由多个翻译单元组成。每个翻译单元均对应一个源代码文件和它所包含的文件。</p>
</blockquote>
<p>###链接</p>
<ul>
<li><p>无链接变量：具有块作用域、函数作用域或函数原型作用域的变量都是无链接变量</p>
</li>
<li><p>外部链接或内部链接：具有文件作用域的变量可以是外部链接和内部链接<br>（通过static控制）</p>
</li>
</ul>
<p>###存储期</p>
<ul>
<li>存储期描述了通过这些标志符访问的对象的生存期。C对象有四种存储期：静态存储期、线程存储期、自动存储期、动态分配存储期</li>
<li>静态存储期：程序运行期间一直存在，文件作用域变量具有静态存储期。</li>
<li>线程存储期：用于并发程序设计。以关键字_Thread_local声明一个对象时，每个线程都活的该变量的私有备份。</li>
<li>自动存储期：块作用域变量通常（排除static）</li>
<li>动态存储期：malloc</li>
</ul>
<table>
<thead>
<tr>
<th>存储类别</th>
<th>存储期</th>
<th>作用域</th>
<th>链接</th>
<th>声明方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>自动</td>
<td>自动</td>
<td>块</td>
<td>无链接</td>
<td>块内</td>
</tr>
<tr>
<td>寄存器</td>
<td>自动</td>
<td>块</td>
<td>无链接</td>
<td>块内，使用关键字register</td>
</tr>
<tr>
<td>静态外部链接</td>
<td>静态存储期</td>
<td>文件</td>
<td>外部</td>
<td>所有函数外</td>
</tr>
<tr>
<td>静态内部链接</td>
<td>静态存储期</td>
<td>文件</td>
<td>内部</td>
<td>所有函数外 使用static</td>
</tr>
<tr>
<td>静态无链接</td>
<td>静态存储期</td>
<td>块</td>
<td>无</td>
<td>块内 使用static</td>
</tr>
</tbody>
</table>
<ul>
<li>寄存器变量 register：编译器必须根据寄存器或最快可用内存数量衡量请求，可能会直接忽略，寄存器变量就变成普通的自动变量。但是仍然不能对该变量使用地址运算符。</li>
<li>块作用域的静态变量：计算机在多次函数调用之间会记录该值<br>不能在函数的形参中使用这个</li>
<li>外部链接的静态变量：定义在所有函数之外的，不用static定义<br>  可在该翻译单元内用extern再次声明或者在在另一个源代码文件内用extern声明    <ul>
<li>与自动变量不同，未初始化外部变量会被自动初始化为0</li>
</ul>
</li>
<li>内部链接的静态变量：不能在另一个源代码文件内使用</li>
</ul>
<p>####auto：表明变量是自动存储期，只能用于块作用域的变量声明。为了明确表达要使用与外部变量同名的局部变量的意图</p>
<p>####register：适用于块作用域的变量，把变量归为寄存器存储类别，保护变量的地址不被获取</p>
<p>####static：对象具有静态存储期，载入程序时创建，结束时消失</p>
<p>####extern：表明声明的变量定义在别处</p>
<ul>
<li>分配内存：malloc()和free():<br>动态分配内存的存储期从调用malloc()分配内存到调用free()释放内存为止。</li>
</ul>
<h1 id="类型限定符"><a href="#类型限定符" class="headerlink" title="类型限定符"></a>类型限定符</h1><ul>
<li>const</li>
<li>volatile类型限定符：告知计算机，代理（而不是变量所在的程序）可以改变该变量的值。如果没有使用volatile，编译器会假定变量的值在使用过程中不变。主要用于<strong>优化</strong></li>
<li>restrict类型限定符：只能用于指针，表明该指针时访问数据对象的唯一且初始的方式。</li>
</ul>
<pre><code class="c"><span class="keyword">for</span>(n=<span class="number">0</span>;n&lt;<span class="number">10</span>;n++)
{
    par[n] += <span class="number">5</span>;
    restar[n] += <span class="number">5</span>;
    ar[n] *= <span class="number">2</span>;
    par[n] +=<span class="number">3</span>;
    restar[n] += <span class="number">3</span>;
}
</code></pre>
<p>如果对restar使用了restrict，则编译器在优化的时候可以直接优化为restar[n] += 8</p>
<ul>
<li>_Atomic类型限定符（C11）：原子类型对象，当一个线程对院子类型的对象执行原子操作时，其他线程不能访问该对象。</li>
</ul>
<h1 id="第十三章-文件输入／输出"><a href="#第十三章-文件输入／输出" class="headerlink" title="第十三章 文件输入／输出"></a>第十三章 文件输入／输出</h1><ul>
<li>fopen() 为标准I/O打开一个文件，并创建于一个用于存储文件和缓冲区信息的结构</li>
<li>fread() 把输入看作是二进制并将其储存在指定存储位置</li>
<li>fscanf(),getc(),fgets(),C将每个字节看作是字符码<br>fscanf()和scanf()函数尝试把字符码翻译成转换说明指定的其他类型</li>
<li>getc()和fgetc()把输入作为字符码储存</li>
<li>对于数字用fprintf将把数字5转换成字符，fwrite则将把这个数字按在内存中占用的4个字节全部写入硬盘</li>
<li>fseek() 第一个参数是FILE指针，第二个参数是偏移量，第三个参数是模式（SEEK_SET,SEEK_CUR,SEEK_END）</li>
<li>ftell() 返回当前位置 </li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/22/C Primer Plus [11-13] 章总结/" data-id="cj4calazs00014q984uqrlt8v" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-C Primer Plus [14-17] 章总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/22/C Primer Plus [14-17] 章总结/" class="article-date">
  <time datetime="2017-05-22T12:28:03.000Z" itemprop="datePublished">2017-05-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="C-Primer-Plus-14-17-章总结"><a href="#C-Primer-Plus-14-17-章总结" class="headerlink" title="C Primer Plus [14-17] 章总结"></a>C Primer Plus [14-17] 章总结</h1><h2 id="第14章-结构和其他数据形式"><a href="#第14章-结构和其他数据形式" class="headerlink" title="第14章 结构和其他数据形式"></a>第14章 结构和其他数据形式</h2><ul>
<li>结构的声明中，可以使用无结构标记<br>例如： </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    <span class="keyword">char</span> title[MAXTITL];</div><div class="line">    <span class="keyword">float</span> value;</div><div class="line">&#125; library;</div></pre></td></tr></table></figure>
<ul>
<li>初始化静态存储期的变量必须使用常值</li>
<li>结构的初始化器</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">library</span> <span class="title">lib</span> = &#123;</span>.title=<span class="string">"Hello World"</span>,.value=<span class="number">22.5</span>&#125;</div></pre></td></tr></table></figure>
<ul>
<li>ANSIC C 及以上版本结构允许双向通信。结构体之间互相赋值</li>
<li>传递结构体变量时使用结构指针，效率更高</li>
<li>复合字面量</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="class"><span class="keyword">struct</span> <span class="title">library</span>&#125;&#123;</span><span class="string">"Hello World"</span>,<span class="number">22.5</span>&#125;</div></pre></td></tr></table></figure>
<ul>
<li>伸缩型数组成员(flexible array member)<ul>
<li>伸缩型数组成员必须是最后一个成员</li>
<li>结构中必须至少有一个成员</li>
<li>声明类似数组，方括号中为空</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flex</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> count;</div><div class="line">	<span class="keyword">double</span> average;</div><div class="line">	<span class="keyword">double</span> scores[];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>希望声明一个指向struct flex 类型的指针，然后用malloc分配足够的空间，以struct flex中常规内容和伸缩性数组成员所需要的额外空间.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flex</span> * <span class="title">pf</span>;</span></div><div class="line">pf = <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(struct flex)+<span class="number">5</span>*<span class="keyword">sizeof</span>(<span class="keyword">double</span>))</div></pre></td></tr></table></figure>
<p>要求：</p>
<pre><code>- 不要使用结构进行赋值或拷贝
- 不要以按值方式把这种结构传递给结构
- 不要使用带伸缩型数组成员的结构作为数组成员或另一个结构的成员，要把结构的地址传递给函数
</code></pre><ul>
<li><strong>联合</strong>：一种数据类型，能在同一个内存中存储不同的数据类型。<br>编译器分配足够的空间以便它能存储联合声明中占用最大字节的类型。<br><strong>联合只允许初始化第1个成员</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">union</span> hold&#123;</div><div class="line">	<span class="keyword">int</span> digit;</div><div class="line">	<span class="keyword">double</span> bigfl;</div><div class="line">	<span class="keyword">char</span> letter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>枚举类型：声明符号名称来表示整型常量。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> spectrum &#123; red,orange,green ,blue ,violet &#125;</div></pre></td></tr></table></figure>
<p>枚举符都是int类型,默认从0开始<br>可以为枚举常量指定整数类型，后面的常量被赋予后续的值</p>
<ul>
<li>函数指针</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ToUpper</span> <span class="params">(<span class="keyword">char</span> * )</span> <span class="comment">// 函数声明</span></span></div><div class="line"></div><div class="line"><span class="title">void</span> <span class="params">(*pf)</span><span class="params">(<span class="keyword">char</span> * )</span> <span class="comment">// 声明函数指针pf.该指针指向的函数接受一个字符指针，返回值为void.</span></div><div class="line"></div><div class="line"><span class="params">(*pf)</span><span class="params">(mis)</span> </div><div class="line"><span class="title">ToUpper</span><span class="params">(mis)</span> <span class="comment">// 两者等价，都表示执行函数ToUpper</span></div></pre></td></tr></table></figure>
<h2 id="第15章-位操作"><a href="#第15章-位操作" class="headerlink" title="第15章 位操作"></a>第15章 位操作</h2><ul>
<li>用法：掩码 设置某些位的开关 flag &amp; MASK</li>
<li>用法：打开位 需要打开一个值的特定位，同时保持其他位不变 flag | MASK</li>
<li>用法：关闭位 需要不影响其他位的情况下关闭指定的位 flag = flag &amp; ~MASK</li>
<li>用法：切换位 打开已关闭的，或关闭已打开的。 flag = flag ^ MASK 将切换该值与MASK为1的位相对应的位</li>
<li>用法：检查位 需要检查某位的值 （flag &amp; MASK）== MASK</li>
<li>位字段：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> autfd :<span class="number">1</span>; </div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> bldfc :<span class="number">1</span>;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> undln :<span class="number">1</span>;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> itals :<span class="number">1</span>;</div><div class="line">&#125; prnt;</div></pre></td></tr></table></figure>
<ul>
<li>声明总位数超过unsigned int 会用到下一个int，会自动移动跨界字段</li>
<li>_Alignas 说明符指定一个变量或类型的对齐值</li>
</ul>
<h2 id="第16章-C预处理器和C库"><a href="#第16章-C预处理器和C库" class="headerlink" title="第16章 C预处理器和C库"></a>第16章 C预处理器和C库</h2><ul>
<li>C预处理器在程序执行之前查看程序，预处理器不做计算，不对表达式求值，只进行替换</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE(X) X*X</span></div></pre></td></tr></table></figure>
<p>X为宏参数列表，X*X为替换列表</p>
<p> #define 中使用参数</p>
<pre><code>- 函数调用在程序运行时把参数的值传递给函数
- 宏调用在编译之前把参数记号传递给程序
</code></pre><ul>
<li>用宏参数创建字符串：#运算符</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PSQR(x) printf(<span class="meta-string">"The square of "</span>#x<span class="meta-string">" is %d .\n"</span>,((x)*(x)))</span></div></pre></td></tr></table></figure>
<p>C允许在字符串中包含宏参数，在类函数宏的替换体中，#号作为一个预处理运算符，可以把记号替换为成字符串，x为宏形参，那么#x就是转换为字符串“x”的形参名</p>
<ul>
<li>预处理器黏合剂：##运算符</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> XNAME(n) x##n</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_XN(n) print(<span class="meta-string">"x"</span>#n<span class="meta-string">"=%d\n"</span>,x##n)</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">XNAME</span><span class="params">(<span class="number">1</span>)</span> </span>= <span class="number">14</span>;</div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">XNAME</span><span class="params">(<span class="number">2</span>)</span> </span>= <span class="number">20</span>;   <span class="comment">// int x2=20</span></div><div class="line">	<span class="keyword">int</span> x3 = <span class="number">30</span>;</div><div class="line">	PRINT_XN(<span class="number">1</span>);	<span class="comment">// printf("x1=%d\n",x1);</span></div><div class="line">	PRINT_XN(<span class="number">2</span>);</div><div class="line">	PRINT_XN(<span class="number">3</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// x1=14</span></div><div class="line"><span class="comment">// x2=20</span></div><div class="line"><span class="comment">// x3=30</span></div></pre></td></tr></table></figure>
<p>运算符把记号组合为一个新的运算符</p>
<ul>
<li>变形参 … 和 <strong>VA_ARGS</strong>  以及后面的可变参数库stdarg.h</li>
<li>宏：宏生成内联代码，在程序中生成语句，不用担心变量类型</li>
<li>文件包含，当预处理器发现#include 指令时会查看后面的文件名并把文件的内容包含到当前文件，替换#include指令的位置<br>UNIX中，尖括号告诉预处理器在标准系统目录中查找该文件。双引号表示首先在当前目录中（或文件名中指定的其他目录）查找该文件，如果未找到再查找标准系统目录</li>
<li>使用头文件，<strong>明示常量</strong>，<strong>宏函数</strong>，<strong>函数声明</strong>，<strong>结构模版定义</strong>，<strong>类型定义</strong></li>
<li>#undef 指令用于“取消”已定义的#define指令</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LIMIT 400</span></div><div class="line"><span class="meta">#<span class="meta-keyword">undef</span> LIMIT</span></div></pre></td></tr></table></figure>
<ul>
<li>#ifdef,#else,#endif</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MAVIS</span></div><div class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"horse.h"</span></span></div><div class="line">	<span class="meta">#<span class="meta-keyword">define</span> STABLES 15</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cow.h"</span></span></div><div class="line">	<span class="meta">#<span class="meta-keyword">define</span> STABLES 15</span></div></pre></td></tr></table></figure>
<ul>
<li>#ifndef：用法与#ifdef用法类似，判断后面的标志符是否是未定义的，常用于定义之前未定义的常量</li>
<li>预定义宏</li>
</ul>
<table>
<thead>
<tr>
<th>宏</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>__DATE__</td>
<td>预处理的日期</td>
</tr>
<tr>
<td>__FILE__</td>
<td>表示当前源代码文件名的字符串字面量</td>
</tr>
<tr>
<td>__LINE__</td>
<td>表示当前源代码文件中行号的整型常量</td>
</tr>
<tr>
<td>__STDC__</td>
<td>设置为1，表明实现遵循C标准</td>
</tr>
<tr>
<td>__STDC<em>HOSTED\</em>_</td>
<td>本机环境设置为1，否则设置为0</td>
</tr>
<tr>
<td>__STDC<em>VERSION\</em>_</td>
<td>支持C99标准，设置为199901L；支持C11标准，设置为201112L</td>
</tr>
<tr>
<td>__TIME__</td>
<td>翻译代码的时间，格式为“hh:mm:ss”</td>
</tr>
<tr>
<td>__func__</td>
<td>代表函数名的字符串</td>
</tr>
</tbody>
</table>
<ul>
<li>#line指令重置<strong>LINE</strong> 和 <strong>FILE</strong></li>
<li>#error 指令让预处理器发送一条错误消息</li>
<li>现在的编译器中，编译器都有自己的编译指示集，可以通过命令行参数或IDE菜单修改编译器的一些设置<br>  #pragma 把编译器指令放入源代码中，可以在源代码中修改编译器的一些设置</li>
<li>泛型选择，没有特定类型，但是一旦指定类型，就可以转换成指定类型的代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MYTYPE(X) _Generic((X),\</span></div><div class="line">	int:<span class="meta-string">"int"</span>,\</div><div class="line">	float:<span class="meta-string">"float"</span>,\</div><div class="line">	double:<span class="meta-string">"double"</span>,\</div><div class="line">	default:<span class="meta-string">"other"</span>\</div></pre></td></tr></table></figure>
<p>*内联函数，C99和C11标准：把函数变成内联函数尽可能快地调用该函数，编译器可能会用内联代码替换函数调用，并执行一些优化。</p>
<ul>
<li>断言,assert()，若表达式为假，就在标准错误流中写入一条错误信息</li>
</ul>
<p>##第17章 高级数据表示</p>
<ul>
<li>ADT抽象数据类型：<ul>
<li>类型名：</li>
<li>类型熟悉：</li>
<li>类型操作：</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/22/C Primer Plus [14-17] 章总结/" data-id="cj4calazu00024q98rr8hk3j2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-C Primer Plus 读后感" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/22/C Primer Plus 读后感/" class="article-date">
  <time datetime="2017-05-22T12:28:03.000Z" itemprop="datePublished">2017-05-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="C-Primer-Plus-读后感"><a href="#C-Primer-Plus-读后感" class="headerlink" title="C Primer Plus 读后感"></a>C Primer Plus 读后感</h1><p>  随着最后最后一章的读完，读完此书的成就也就达成了。<br>  总体而言，本书更偏基础，作为一名重读C语言的科班大三学生来说，重读这本书带给我更多的是回顾。变量的定义，函数的调用，结构体的声明，这些在我看来早已用了N次的东西，在这都介绍的十分详细。原以为可以从此书中获取一些C语言编译器实现的知识，但是并没有，反而教授了我更多C语言细节方面的内容，以及各个版本之间的区别。算是真正扎实了C语言功底吧。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/22/C Primer Plus 读后感/" data-id="cj4calazw00034q98v91zlws7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-C++ Primer Plus [1-4] 章总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/22/C++ Primer Plus [1-4] 章总结/" class="article-date">
  <time datetime="2017-05-22T12:28:03.000Z" itemprop="datePublished">2017-05-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="C-Primer-Plus-1-4-章总结"><a href="#C-Primer-Plus-1-4-章总结" class="headerlink" title="C++ Primer Plus [1-4] 章总结"></a>C++ Primer Plus [1-4] 章总结</h1><h2 id="第1章-预备知识"><a href="#第1章-预备知识" class="headerlink" title="第1章 预备知识"></a>第1章 预备知识</h2><ul>
<li>C++诞生于贝尔实验实验室，Bjarne Stroustrup 于20世纪80年代开发出。</li>
<li>1990 美国国家标准局（ANSI）专门负责制定C++标准。国际标准化组织（ISO）很快加入行列，一起制定C++标准<br>  C++98 -&gt; C++98/C++03 -&gt; C++11</li>
<li>UNIX编译和链接：编译，编译器生成一个扩展名为.o的目标代码文件，编译器自动将目标代码文件传递给系统链接程序，生成可执行文件a.out。如果只使用一个源文件，链接程序将删除spiffy.o。如果有多个则不删，方便下次链接。</li>
</ul>
<h2 id="第2章-开始学习C"><a href="#第2章-开始学习C" class="headerlink" title="第2章 开始学习C++"></a>第2章 开始学习C++</h2><ul>
<li>通常，main函数被启动代码调用，启动代码由编译器添加到程序中</li>
<li><p>名称空间，有助于组织程序。防止不同文件中相同的名称之间干扰</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  <span class="comment">//放在函数之前，让文件中左右函数都能够使用名称空间std中所有的元素。</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">//放在特定的函数定义中，让该函数能够使用名称空间std中的所有元素</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</div><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">std</span>; <span class="comment">// 在特定的函数使用此，使得特定的函数能够实用制定的元素</span></div><div class="line"></div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="comment">// 完全不使用编译指令</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="第3章-处理数据"><a href="#第3章-处理数据" class="headerlink" title="第3章 处理数据"></a>第3章 处理数据</h2><ul>
<li><p>默认情况下，cout以十进制格式显示整数。</p>
<ul>
<li>dec 指示cout以十进制输出</li>
<li>hex 指示cout以十六进制输出</li>
<li><p>oct 指示cout以八进制输出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// std空间中 </span></div><div class="line">  <span class="built_in">cout</span>&lt;&lt;dec</div><div class="line">  <span class="built_in">cout</span>&lt;&lt;hex</div><div class="line">  <span class="built_in">cout</span>&lt;&lt;oct</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>C++ 默认将整型常量存储为int 。除非有说明 有后缀L，太大，<br>对于不带后缀的十进制数，使用以下中最小类型<br>int ,long 或 long long<br>对于不带后缀的十六进制或八进制整数，是用以下中最小类型<br>int , unsigned int ,long ,unsigned long ,long long ,unsigned long long </p>
</li>
<li>C++11 新增char16_t,char32_t<br>使用前缀u表示char16_t字符常量和字符串常量 u’C’ u”be good”<br>使用前缀U表示char32_t常量U’R’ U’dirty rat’</li>
<li><p>类型转换</p>
<ul>
<li>初始化和赋值进行的转换：值将被转换为接受变量的类型</li>
<li>以{}方式初始化时进行的转换：较为严格，列表初始化不允许<strong>缩窄</strong></li>
<li><p>表达式中的转换：</p>
<ul>
<li>bool,char,unsigned char ,signed char 和 short值转换为int <strong>整型提升</strong></li>
<li>运算涉及两种类型时，较小的类型将被转换为较大的类型</li>
</ul>
</li>
<li><p>传递参数时的转换：由C++原型控制</p>
</li>
<li>强制类型转换：<br>(typename) value<br>typename (value)</li>
</ul>
</li>
<li><strong>auto</strong> C++11新增加auto,让编译器能够更加初始值的类型推断变量的类型。与C大不同</li>
</ul>
<h2 id="第4章-复合类型"><a href="#第4章-复合类型" class="headerlink" title="第4章 复合类型"></a>第4章 复合类型</h2><ul>
<li>输入读取</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cin</span>&gt;&gt;  <span class="comment">//cin使用空白（空格，制表符和换行符）来确定字符串的结束位置</span></div><div class="line"><span class="built_in">cin</span>.getline() <span class="comment">// 读取一行，直到到达换行符，丢弃换行符</span></div><div class="line"><span class="built_in">cin</span>.get() <span class="comment">// 读取一行，当遇到换行符时结束，将换行符保留在输入序列中</span></div></pre></td></tr></table></figure>
<ul>
<li>C++98 通过string类扩展了C++库<br>  string 类具有自动调整大小的功能<ul>
<li>可以将一个string对象赋值给另一个string对象</li>
<li>可以添加到另一个对象末尾</li>
</ul>
</li>
<li>原始字符串raw，原始字符串中\n不表示换行符</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">R"(Jim "</span>King<span class="string">" Tutt uses "</span>\n<span class="string">" instead of endl.)"</span>;</div><div class="line"></div><div class="line"><span class="built_in">cout</span>&lt;&lt; <span class="string">R"+*("</span>Who wouldn't?)<span class="string">",she whispered.)+*"</span>&lt;&lt;<span class="built_in">endl</span>;	<span class="comment">// 使用“+*( 和 )+*" 替代默认界定符“(和)"</span></div></pre></td></tr></table></figure>
<ul>
<li>C++允许在声明结构变量时省略关键字struct</li>
<li>共用体 union  与C类似，匿名共用体</li>
<li>枚举 enum</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> spectrum &#123;red,orange,yellow,green,blue,violet,indigo,ultraviolet&#125;;</div><div class="line"> </div><div class="line">spectrum band;</div><div class="line">band = <span class="number">4</span> ;<span class="comment">// 非法	在不进行强制类型转换的情况下，只能将定义枚举时使用的枚举量赋给这种枚举的变量 </span></div><div class="line">band = red; <span class="comment">// 可以</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> color = blue;</div><div class="line">color = <span class="number">3</span>+red; <span class="comment">// 可以，枚举量时整型，可被提升为int类型，但int类型不能自动转换为枚举类型</span></div></pre></td></tr></table></figure>
<p>枚举的范围：每个枚举都有取值范围，通过强制类型转换可以将取值范围中的任何整数赋给枚举变量。上限：找到大于这个最大值的最小的2的幂减1.下限：不小于0则取0，否则找到小于这个最小值的最小的2的幂加1</p>
<ul>
<li>指针<br>  使用new来创建动态数组</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *psome = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">10</span>]; <span class="comment">//[] 中可以是使用变量</span></div><div class="line">delet [] psome;</div></pre></td></tr></table></figure>
<pre><code>- 不用使用delete来释放不是new分配的内存
- 不要用delete释放两次
- 对空指针应用delete是安全的
</code></pre><ul>
<li>数组：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">short</span> tell[<span class="number">10</span>];</div><div class="line"><span class="built_in">cout</span>&lt;&lt;tell&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"><span class="built_in">cout</span>&lt;&lt;&amp;tell&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"><span class="comment">//从数字上说两个地址相同。但是概念上 tell是是一个两个字节内存块的地址，</span></div><div class="line"><span class="comment">//&amp;tell是一个指向包含20个元素的short数组的指针</span></div></pre></td></tr></table></figure>
<ul>
<li>模板类:vector和array (C++11)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line">vecotor&lt;<span class="keyword">int</span>&gt;vi; <span class="comment">// vector对象在你插入或添加值时自动调整长度</span></div><div class="line">vecotor&lt;<span class="keyword">int</span>&gt; vd(<span class="number">5</span>); <span class="comment">// 也可以指定长度</span></div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></div><div class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt; ai; <span class="comment">//长度固定的数组,可以互相赋值</span></div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/22/C++ Primer Plus [1-4] 章总结/" data-id="cj4calazx00044q980p6ho96q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/06/24/反应堆/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/06/21/Nginx/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/05/30/服务器端编程介绍/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/05/24/C++ Primer Plus[5-9] 章总结/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/05/22/C Primer Plus [1-10] 章总结/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>