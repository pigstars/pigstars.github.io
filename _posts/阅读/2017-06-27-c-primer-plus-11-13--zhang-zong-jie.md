---
layout: post
title: "C Primer Plus [11-13] 章总结"
description: ""
category: "阅读"
tags: "C Prim Plus"
---

## 第11章 字符串与字符串函数
* 从ANSI标准起，如果字符串字面量之间没有间隔，或者用空白字符间隔，C将其视为串联起来的字面量
  例如：
   
```C
char greet[50]="Hello,""how are you"    "are you ok?"
  等价于
char greet[50]="Hello,how are you are you ok"
```
  
* 初始化数组是把静态存储区的字符串拷贝到数组中，而初始化指针只把字符串的地址拷贝给指针，（当通过该地址修改字符串时，再次输出相同与静态存储区的值可能会发生变化）
例如：

```C
char *p1 = “Klingon”;
p1[0] = 'F';
print("Klingon");
print(":Beware the %s!\n","Klingon")
	// 打印结果可能为 Flingon
```
* gets函数可能存在读入的长度超过数组长度的问题
替代函数
fgets()函数：
	第1个参数表示储存的数组
	第2个参数限制读入的字符数来解决溢出的问题
	第3个参数指明要读入的文件
	不添加换行符
get_s()函数：
	只从标准输入中读取数据
	读到换行符会丢弃
	读到最大字符数没有读到换行符，执行以下首先把目标数组中的首字符设置为空字符，读取并丢弃随后的输入直至读到换行符或文件结尾，然后返回空指针。

* strncmp() 可以比较到字符不同的地方，也可以只比较第3个参数所指定的字符数
* strncpy() 第三个参数指明可拷贝的最大字符数
* sprintf()函数将数据写入字符串，而不是打印在显示器
* 命令行参数

```c
int main(int argc, char const *argv[])
```
argc 表示参数个数
argv 表示指向参数数组指针的指针
argv[0] 表示程序名

## 第12章 存储类别，链接和内存管理

### 作用域
* 作用域描述程序中可访问标志符的区域
C变量的作用域可以是
	- 块作用域
	- 函数作用域
	- 函数原型作用域
	- 文件作用域

* 块作用域：从定义处到包含该定义的块的末尾，局部变量（包括函数的形式参数） C99允许在块中的任意位置声明变量

* 函数作用域：仅用于GOTO语句的标签

* 函数原型作用域：用于函数原型中的形参名

```C
int mighty(int mouse,double large)
```
范围是从形参定义处到原型声明结束，编译器在处理函数原型中的形参时，只关心类型，而形参名无关紧要。

文件作用域：变量定义在函数的外部，也称为全局变量

翻译单元
>编译器源代码文件和所有的头文件看成是一个包含信息的单独文件，称为翻译单元。描述一个具有文件作用域的变量时，它的实际可见范围是整个翻译单元。
>如果程序由多个源代码文件组成，那么该程序也将由多个翻译单元组成。每个翻译单元均对应一个源代码文件和它所包含的文件。

### 链接
* 无链接变量：具有块作用域、函数作用域或函数原型作用域的变量都是无链接变量

* 外部链接或内部链接：具有文件作用域的变量可以是外部链接和内部链接
（通过static控制）

### 存储期
* 存储期描述了通过这些标志符访问的对象的生存期。C对象有四种存储期：静态存储期、线程存储期、自动存储期、动态分配存储期
* 静态存储期：程序运行期间一直存在，文件作用域变量具有静态存储期。
* 线程存储期：用于并发程序设计。以关键字_Thread_local声明一个对象时，每个线程都活的该变量的私有备份。
* 自动存储期：块作用域变量通常（排除static）
* 动态存储期：malloc

存储类别 | 存储期 | 作用域 | 链接 | 声明方式
---- | ---- | ---- | ---- | ---- 
自动	| 自动 | 块 | 无链接 | 块内
寄存器 | 自动 | 块 | 无链接 | 块内，使用关键字register
静态外部链接 | 静态存储期 | 文件 | 外部 | 所有函数外
静态内部链接 | 静态存储期 | 文件 | 内部 | 所有函数外 使用static
静态无链接 | 静态存储期 | 块 | 无 | 块内 使用static

* 寄存器变量 register：编译器必须根据寄存器或最快可用内存数量衡量请求，可能会直接忽略，寄存器变量就变成普通的自动变量。但是仍然不能对该变量使用地址运算符。
* 块作用域的静态变量：计算机在多次函数调用之间会记录该值
  不能在函数的形参中使用这个
* 外部链接的静态变量：定义在所有函数之外的，不用static定义
	可在该翻译单元内用extern再次声明或者在在另一个源代码文件内用extern声明	
	- 与自动变量不同，未初始化外部变量会被自动初始化为0
* 内部链接的静态变量：不能在另一个源代码文件内使用

#### auto：表明变量是自动存储期，只能用于块作用域的变量声明。为了明确表达要使用与外部变量同名的局部变量的意图
#### register：适用于块作用域的变量，把变量归为寄存器存储类别，保护变量的地址不被获取
#### static：对象具有静态存储期，载入程序时创建，结束时消失
#### extern：表明声明的变量定义在别处

* 分配内存：malloc()和free():
动态分配内存的存储期从调用malloc()分配内存到调用free()释放内存为止。

# 类型限定符
* const
* volatile类型限定符：告知计算机，代理（而不是变量所在的程序）可以改变该变量的值。如果没有使用volatile，编译器会假定变量的值在使用过程中不变。主要用于**优化**
* restrict类型限定符：只能用于指针，表明该指针时访问数据对象的唯一且初始的方式。

```c
for(n=0;n<10;n++)
{
	par[n] += 5;
	restar[n] += 5;
	ar[n] *= 2;
	par[n] +=3;
	restar[n] += 3;
}
``` 
如果对restar使用了restrict，则编译器在优化的时候可以直接优化为restar[n] += 8
* _Atomic类型限定符（C11）：原子类型对象，当一个线程对院子类型的对象执行原子操作时，其他线程不能访问该对象。

# 第十三章 文件输入／输出

* fopen() 为标准I/O打开一个文件，并创建于一个用于存储文件和缓冲区信息的结构
* fread() 把输入看作是二进制并将其储存在指定存储位置
* fscanf(),getc(),fgets(),C将每个字节看作是字符码
  fscanf()和scanf()函数尝试把字符码翻译成转换说明指定的其他类型
* getc()和fgetc()把输入作为字符码储存
* 对于数字用fprintf将把数字5转换成字符，fwrite则将把这个数字按在内存中占用的4个字节全部写入硬盘
* fseek() 第一个参数是FILE指针，第二个参数是偏移量，第三个参数是模式（SEEK_SET,SEEK_CUR,SEEK_END）
* ftell() 返回当前位置 


