---
layout: post
title: " C++ Primer Plus[10-13] 章总结"
description: "description"
category: "阅读"
tags: "CppPrimerPlus"
---
# C++ Primer Plus[10-13] 章总结
## 第10章 对象和类
* 抽象：将问题的本特征抽象出来，并根据特征来描述解决方案。
* 类是一种将抽象转换为用户定义类型的C++工具，将数据表示和操纵数据的方法组合成一个整洁的包。
* 访问控制：private ：类对象的默认访问控制。类方法可以访问类的private组件
* 实现成员函数时，使用作用域解析运算符（::）来标识函数所属的类
* **内联方法**：定义位于类声明中的函数都将自动成为内联函数。类声明常常将短小的成员函数作为内联函数。
* 所创建的类对象都有自己的存储空间，用于存储其内部变量和类成员，但同一个类的所有对象共享同一组类方法
* 构造函数没有声明类型，参数名不能与类成员相同。两种做法：一种数据成员名中使用m\_前缀，另一种成员名中使用后缀_。
* 构造函数的使用：
    - 显式调用： Stock food = Stock("Wrold Cabbage",250,125)
    - 隐式调用： Stock garment(“Furry MAson”，50，25)
* 当没有定义任何构造函数时，编译器才会提供构造函数。
 如果提供了默认构造函数，需要将参数赋默认值，才有默认构造函数的效果。
* 自动变量存放在栈中，因此最后创建的对象将最先删除。
* **const**将const关键字放在函数的声明与定义，放于函数括号后面。用于告知类方法不修改调用对象。也将this指针设立为const。
* 作用域为类的常量：
    - 使用enum{Months = 12} 这种方式声明枚举不会创建类数据成员。在作用域为整个类的代码中遇到他，编译器会用12代替
    - static const 定义。该常量将于其他静态变量存储在一起。

## 第11章 使用类
* 不要返回指向局部变量或临时对象的引用
* 友元： 通过让函数成类的友元，可以赋予该函数与类的成员函数相同的访问权限。
  - 将原型放在类的声明中 friend Time operator *(double m ,const Time & t); 友元函数不是类的成员函数
* 重载运算符
  - 成员函数时，所需参数数目少一，因为其中的一个操作数是被隐式地传递的调用对象
  - 非成员函数时，一般是友元函数。
* 类的转换
类型->类
 转换函数：接受一个参数的构造函数可作为转换函数，可自动执行隐式转换。
 使用关键字explicit可用于关闭隐式转换，允许显示转换。
类->类型
 转换函数：operator typeName() typeName表示类型
 该转换函数没有返回类型，没有参数，但必须返回转换后的值。
 
## 第12章 类和动态内存分配
 * 静态类成员，无论创建多少对象，程序只创建一个静态类变量副本。
   静态数据成员在类声明中声明，在包含类方法的文件中初始化。初始化时使用作用域运算符来指出静态成员所属的类，若静态成员时const整数类型，则可在类声明中初始化。
   
C++ 自动提供以下成员函数：默认构造函数，默认析构函数，复制构造函数，赋值运算符，地址运算符
* 复制构造函数 
    复制构造函数用于将一个对象复制到新创建的对象中。
    
```C
StringBad::StringBad(const String &st)
{
} // 复制构造函数定义的基本样子

StringBad ditt(motto);
StringBad metoo = motto;
StringBad also = StringBad(motto);
StringBad * pStringBad = new StringBad(motto);
//以上几种声明都将调用复制构造函数，函数按值传递或返回对象时都将调用构造函数。
//默认构造功能：逐个浅复制非静态成员的值
```
* 赋值运算符
    原型：
    
    ```C
    StringBad & StringBad::operator=(const StringBad &st);
    
    String knot;
    knot = headline1;
    // 当使用=运算符时，若对象已经建立，则调用赋值运算符
    // 赋值运算符是只能由类成员函数重载的运算符之一
    ```
* 定位new：使用定位new运算符将对象分配到指定内存位置时。当释放内存时，首先应该与创建顺序相反的顺序进行显示的调用析构函数，然后再释放块内存。
* 构造函数使用new ，析构函数使用delete 。构造函数使用new [] 析构函数使用delete []；

* 成员初始化列表
如果Classy是一个类，而mem1、mem2、mem3都是这个类的数据成员。则类构造函数可以使用如下的语法来初始化数据成员：

```C
Classy::Classy(int n,int m):mem1(n),mem2(0),mem3(n*m+2)
{
}
//这种格式只能用于构造函数
//必须用这种格式来初始化非静态const数据成员，引用数据成员
```

## 第13章 类继承
* 派生类构造函数必须使用基类构造函数。创建派生类对象时，程序首先创建基类对象。

```C
Ob::Ob(int x,int y,int z):BaseOb(y,z)
{
    x_ = x;
}
// 构造函数把实参赋给x,y,z 然后把这恶血参数作为实参船体给BaseOb构造函数。必须首先创建基类对象，如果不调用基类对象，程序将使用默认的基类构造函数。

```

* **类指针** 基类指针、引用可以在不进行显式类型转换的情况下指向派生类对象。然而，基类指针或引用只能用于调用基类方法。而反之则不能隐式调用。
* 虚方法：关键字 virtual。方法在基类中被声明为虚后，在派生类中将自动成为虚方法。
  若在派生类中重新定义基类方法，通常应该将基类方法定义为虚方法。若为虚方法：程序根据对象类型选择方法版本。若为非虚方法：程序根据指针类型选择方法版本。常用虚析构函数。
  编译器对非虚方法使用静态联编，对虚方法使用动态联编。
* 虚函数注意事项
    - 构造函数不能是虚方法。
    - 析构函数应当是虚函数。
    - 友元函数不能是虚函数。
    - 若没有重新定义，将使用该函数的基类版本
    - 重新定义将隐藏所有同名基类方法
* protected：派生类的成员可以直接访问基类的保护成员，但不能直接访问基类的私有成员。
* 抽象基类：C++通过使用纯虚函数提供未实现的函数。纯虚函数声明的结尾处为=0

```C
virtual double Area() const = 0;//纯虚函数
//当类中包含纯虚函数时，则不能创建该类的对象。
```





